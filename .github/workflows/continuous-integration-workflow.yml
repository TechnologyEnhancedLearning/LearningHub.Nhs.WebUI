name: Continuous Integration
on: [push]
env:
  BuildParameters.RestoreBuildProjects: '**/*.csproj'
  BuildParameters.TestProjects: '**/*[Tt]ests/*.csproj'
  
  # Nuget Feed Credentials
  TEL_GITHUB_DEVOPS_USERNAME: ${{ secrets.TEL_GITHUB_DEVOPS_USERNAME }}
  TEL_GITHUB_PACKAGE_READ_PAT: ${{ secrets.TEL_GITHUB_PACKAGE_READ_PAT }}
  TEL_AZURE_DEVOPS_USERNAME: ${{ secrets.TEL_AZURE_DEVOPS_USERNAME }}
  TEL_AZURE_DEVOPS_PAT: ${{ secrets.AZURE_DEVOPS_PAT }}
jobs:
  build:
    name: Build and test
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup .NET Core SDK 8.0
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x     

      # Todo: remove check once all pipeline work and have the file         
      - name: Check if nuget.config.cicd exists
        id: check_nuget_cicd
        run: |
          if (Test-Path "nuget.config.cicd") {
            echo "exists=true" >> $env:GITHUB_OUTPUT
            echo "nuget.config.cicd exists"
          } else {
            echo "exists=false" >> $env:GITHUB_OUTPUT
            echo "nuget.config.cicd doesnt exist"
          }
        shell: pwsh
       
      # Remove local nuget.config (Should be gitignored) and create nuget.config from nuget.config.cicd
      # Todo: remove if once all pipeline work and have the file  
      - name: Setup NuGet with CICD config
        if: steps.check_nuget_cicd.outputs.exists == 'true'
        run: |
          if (Test-Path "nuget.config") { Remove-Item "nuget.config" }
          Copy-Item "nuget.config.cicd" "nuget.config"
        shell: pwsh
          
      # Replace env values with github secrets    
      - name: Replace environment variables in nuget config
        if: steps.check_nuget_cicd.outputs.exists == 'true'
        run: |
          (Get-Content nuget.config) -replace '%TEL_GITHUB_DEVOPS_USERNAME%', $env:TEL_GITHUB_DEVOPS_USERNAME | Set-Content nuget.config
          (Get-Content nuget.config) -replace '%TEL_GITHUB_PACKAGE_READ_PAT%', $env:TEL_GITHUB_PACKAGE_READ_PAT | Set-Content nuget.config
          (Get-Content nuget.config) -replace '%TEL_AZURE_DEVOPS_USERNAME%', $env:TEL_AZURE_DEVOPS_USERNAME | Set-Content nuget.config
          (Get-Content nuget.config) -replace '%TEL_AZURE_DEVOPS_PAT%', $env:TEL_AZURE_DEVOPS_PAT | Set-Content nuget.config
        shell: pwsh
         
      # Todo: remove fallback once all pipeline work and have the file 
      - name: Setup NuGet with Azure DevOps (fallback)
        if: steps.check_nuget_cicd.outputs.exists == 'false'
        run: |
          dotnet nuget remove source LearningHubFeed || true
          dotnet nuget add source 'https://pkgs.dev.azure.com/e-LfH/_packaging/LearningHubFeed/nuget/v3/index.json' --name 'LearningHubFeed' --username 'kevin.whittaker' --password ${{ secrets.AZURE_DEVOPS_PAT }} --store-password-in-clear-text
         
      
      - name: Use Node 14
        uses: actions/setup-node@v4
        with:
          node-version: '14'
          cache: 'npm'  
          
      - name: npm install WebUI
        run: npm install 
        working-directory: ./LearningHub.Nhs.WebUI
      
      - name: npm build WebUI
        run: npm run build:webpack
        working-directory: ./LearningHub.Nhs.WebUI     
      
      - name: npm install AdminUI
        run: npm install 
        working-directory: ./AdminUI/LearningHub.Nhs.AdminUI
      
      - name: npm build AdminUI
        run: npm run build:webpack
        working-directory: ./AdminUI/LearningHub.Nhs.AdminUI   
      
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1.0.3
        
      - name: Build SQL Server Database Project
        run: |
          # Enable strict error handling
          $ErrorActionPreference = 'Stop'
      
          # Initialize an error collection
          $errors = @()
      
          # List all .sqlproj files
          $sqlproj_files = Get-ChildItem -Path . -Filter *.sqlproj -Recurse
      
          if ($sqlproj_files.Count -eq 0) {
            $errors += "No .sqlproj files found."
          } else {
            foreach ($sqlproj_file in $sqlproj_files) {
              Write-Host "Building $($sqlproj_file.FullName)"
              try {
                $output = &msbuild "$($sqlproj_file.FullName)" /p:Configuration=Release /nologo 2>&1
                if (!$?) {
                  $errors += "Failed to build $($csproj_file.FullName): $output"
                }
              } catch {
                # Capture detailed error information
                $errorMessage = "Error building $($sqlproj_file.FullName): $($_.Exception.Message)"
                Write-Host $errorMessage
                $errors += $errorMessage
              }
            }
          }
      
          # Display all accumulated errors
          if ($errors.Count -gt 0) {
            Write-Host "SQL Project Build Errors:"
            $errors | ForEach-Object { Write-Host $_ }
            exit 1
          }
      
      - name: Build Solution Excluding SQL Project
        run: |
          # Enable strict error handling
          $ErrorActionPreference = 'Stop'
      
          # Initialize an error collection
          $errors = @()
      
          # List all .csproj files except .sqlproj
          $csproj_files = Get-ChildItem -Path . -Filter *.csproj -Recurse | Where-Object { $_.FullName -notmatch '\\.sqlproj$' }
      
          if ($csproj_files.Count -eq 0) {
            $errors += "No .csproj files found."
          } else {
            foreach ($csproj_file in $csproj_files) {
              Write-Host "Building $($csproj_file.FullName)"
              try {
                $output = &dotnet build "$($csproj_file.FullName)" --configuration Release 2>&1
                if (!$?) {
                  $errors += "Failed to build $($csproj_file.FullName): $output"
                }
              } catch {
                # Capture detailed error information
                $errorMessage = "Error building $($csproj_file.FullName): $($_.Exception.Message)"
                Write-Host $errorMessage
                $errors += $errorMessage
              }
            }
          }
        
           # Display all accumulated errors
          if ($errors.Count -gt 0) {
            Write-Host "Solution Build Errors:"
            $errors | ForEach-Object { Write-Host $_ }
            exit 1
          }
          
      # - name: Test
        # run: dotnet test ${{ env.BuildParameters.TestProjects }}            
